//--Author	D Glazier    XXth Jun 2007	
//--Rev         JRM Annand   20th Jul 2007  Adapt for AcquMC foam  
//--Rev         JRM Annand   25th Jun 2008  Use WgtDensity  
//--Update      DI Glazier   12th Feb 2009  Add RecoilPol for CM, flRecPol
//--Update      DI Glazier   30th Apr 2010  Fix azimuthal distributions

//--Description
//                *** Acqu++ <-> Root ***
// Online/Offline Analysis of Sub-Atomic Physics Experimental Data 
//
// TMCPhotoPSInt
//
// Use data base generated by SAID partial wave analysis
// Database contains 16 observables associated with photoproduction of
// pseudo-scalar mesons and is tabulated as a function of incident photon
// energy and CM polar angle of meson. Phi dependence is calculated from
// observables when TFoam is initialised (TFoam dimension 3). Target
// Polarisation constitutes an optional 4th dimension

#include "TMCPhotoPSInt.h"
#include "ARFile_t.h"

ClassImp(TMCPhotoPSInt)

//-----------------------------------------------------------------------------
TMCPhotoPSInt::TMCPhotoPSInt( Int_t n, Double_t* scale, TA2System* sys,
			      Int_t idens )
: TMCFoamInt( n, scale, sys, idens )
{
  fPSO = new Double_t[ENPhotoPSObs];
  flRecPol = new TLorentzVector();
}

//-----------------------------------------------------------------------------
TMCPhotoPSInt::~TMCPhotoPSInt()
{
  delete fPSO;
  delete flRecPol;
}

//-----------------------------------------------------------------------------
void TMCPhotoPSInt::RecoilPol( Double_t rp_phi )
{
  // Polaristaion of post-meson production recoil nucleon
  //in CM frame
  GenPSO();
  Double_t Px=0;
  Double_t Py=0;
  Double_t Pz=0;
  if( fPolR->X() ) Px = ( -fPolB->X()*fPSO[EpsoOX]*sin(2*rp_phi) - 
			 fPolB->Z()*fPSO[EpsoCX] +
			 fPolT->X()*cos(rp_phi)*fPSO[EpsoTX] -
			 fPolT->Z()*fPSO[EpsoLX])/
                         (1-fPolB->X()*fPSO[EpsoS]*cos(2*rp_phi));
  if(fPolR->Y()) Py = ( fPSO[EpsoP]-fPolB->X()*fPSO[EpsoT]*cos(2*rp_phi) +
		       fPolT->Y()*sin(rp_phi)*fPSO[EpsoS])/
                       (1-fPolB->X()*fPSO[EpsoS]*cos(2*rp_phi));
  if(fPolR->Z()) Pz = ( -fPolB->X()*fPSO[EpsoOZ]*sin(2*rp_phi) -
		       fPolB->Z()*fPSO[EpsoCZ] +
		       fPolT->X()*cos(rp_phi)*fPSO[EpsoTZ] +
		       fPolT->Z()*fPSO[EpsoLZ])/
                       (1-fPolB->X()*fPSO[EpsoS]*cos(2*rp_phi));;
  flRecPol->SetXYZT(Px,Py,Pz,0);
}

//-----------------------------------------------------------------------------
void TMCPhotoPSInt::RecoilPol( Double_t rp_eg, Double_t rp_thpcm,
			       Double_t rp_phi, Double_t rp_thpl,
			       Double_t rp_gamma )
{
  //This function needs checked and fixed do not use
  return;
  // Polaristaion of post-meson production recoil nucleon
  //in lab frame
  GenPSO();
  Double_t Px=0;
  Double_t Py=0;
  Double_t Pz=0;
  if( fPolR->X() ) Px = ( -fPolB->X()*fPSO[EpsoOX]*sin(2*rp_phi) - 
			 fPolB->Z()*fPSO[EpsoCX] +
			 fPolT->X()*cos(rp_phi)*fPSO[EpsoTX] -
			 fPolT->Z()*fPSO[EpsoLX])/
                         (1-fPolB->X()*fPSO[EpsoS]*cos(2*rp_phi));
  if(fPolR->Y()) Py = ( fPSO[EpsoP]-fPolB->X()*fPSO[EpsoT]*cos(2*rp_phi) +
		       fPolT->Y()*sin(rp_phi)*fPSO[EpsoS])/
                       (1-fPolB->X()*fPSO[EpsoS]*cos(2*rp_phi));
  if(fPolR->Z()) Pz = ( -fPolB->X()*fPSO[EpsoOZ]*sin(2*rp_phi) -
		       fPolB->Z()*fPSO[EpsoCZ] +
		       fPolT->X()*cos(rp_phi)*fPSO[EpsoTZ] +
		       fPolT->Z()*fPSO[EpsoLZ])/
                       (1-fPolB->X()*fPSO[EpsoS]*cos(2*rp_phi));;
  flRecPol->SetXYZT(Px,Py,Pz,0);
  //Actually G4 takes polarisation in CM frame so ignore rest!!!!
  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  //Calculated polarisation is in CM need to rotate to LAB.
  //USe transformation matrix defined in Appendix of PRC66 034614
  //All needs checked!!!!!!!!Particlulartly direction of rotationY
   Double_t thRot = acos(cos(rp_thpl)*cos(rp_thpcm) +
  			rp_gamma*sin(rp_thpl)*sin(rp_thpcm));
   fCMtoLAB->RotateY(-thRot);
  //Rotate to double-primed frame which is equivalent
  //to the G4 particle frame(where polarised scattering is
  //computed) that requires a rotateUZ.(inc)
  //to get back to overall lab. frame
   // flRecPol*=fCMtoLAB;
   //*fCMtoLAB *= fCMtoLAB->Inverse();//make unity again!
  //fCMtoLAB.RotateY(Throt); 
}

//-----------------------------------------------------------------------------
void TMCPhotoPSInt::ReadData(Char_t* dbname)
{
  // Read SAID database file and pass variables to TMCPhotoPSInt
  // the integrand class to generate SAID foam.
  // Any line parse error treated as FATAL
  // If read-in successful create the associated integrand class TMCPhotoPSInt

  fSN = new Int_t[fNDim];
  fXN = new Double_t*[fNDim];
  Double_t E,Th;
  Double_t val[ENPhotoPSObs];
  Int_t ie;
  Int_t idb = 0;
  Int_t nE,nTh;

  ARFile_t infile(dbname,"r",fSys);
  Char_t* line;

  // Read # photon energies and # polar angles for each energy
  line = infile.ReadLine();
  if( sscanf( line, "%d%d", &nE, &nTh ) != 2 )
    fprintf(fSys->GetLogStream(),"TMCPhotoPSInt: <Database file parse>");
  fSN[EEgamma] = nE; fSN[ETheta] = nTh; fSN[EPhi] = 2;
  fXN[EEgamma] = new Double_t[nE]; fXN[ETheta] = new Double_t[nTh];
  // Put in phi by hand, also target if # dimensions = 4
  fXN[EPhi] = new Double_t[2];
  fXN[EPhi][0] = 0.0; fXN[EPhi][1] = TMath::TwoPi();
  if( fNDim > ETarget ){
    fSN[ETarget] = 2;
    fXN[ETarget] = new Double_t[2];
    fXN[ETarget][0] = -1; fXN[ETarget][1] = 1;
  }
  fNIntp = nE * nTh;	
  fYN = new Double_t[nE * nTh * ENPhotoPSObs];

  // Loop to read incident photon energies in MeV
  for( ie=0; ie<nE; ie++ ){
    if( !(line = infile.ReadLine()) ) break;
    if( sscanf( line, "%lf", &E ) != 1 )
      fprintf(fSys->GetLogStream(),"TMCPhotoPSInt: <Database file parse>");
    fXN[EEgamma][ie] = E * 0.001;              // MeV -> GeV
    // Loop to read CM polare angles in deg.
    for( Int_t ith=0; ith<nTh; ith++ ){
      if( !(line = infile.ReadLine()) ) break;
      if( sscanf( line, "%lf", &Th ) != 1 )
	fprintf(fSys->GetLogStream(),"TMCPhotoPSInt<Database file parse>");
      Th *= TMath::DegToRad();                 // deg. -> radian
      fXN[ETheta][ith] = Th; 
      // Read 16 observables for current energy and angle
      if( !(line = infile.ReadLine()) ) break;
      if( sscanf(line,"%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf",
	  val,   val+1, val+2, val+3, val+4, val+5, val+6, val+7,
	  val+8, val+9, val+10,val+11,val+12,val+13,val+14,val+15) != 16 )
	fprintf(fSys->GetLogStream(),"<TMCPhotoPSInt: Database file parse>");
      val[EpsoDSG] *= TMath::Sin(Th);          // dsigma/domega -> dsigma
      for(Int_t io=0; io<ENPhotoPSObs; io++){
	fYN[io*nE*nTh + idb] = val[io];
      }
      idb++;
    }
  }
  if( ie != nE )
    fprintf(fSys->GetLogStream(),
	    "TMCPhotoPSInt: <Database file non-matching number of energies>");
  for( Int_t j=0; j<fNDim; j++ ){
    fScale[2*j] = fXN[j][0];
    fScale[2*j+1] = fXN[j][fSN[j]-1];
  } 
}

